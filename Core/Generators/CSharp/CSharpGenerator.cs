using Core.Meta;
using Core.Meta.Extensions;
using Core.Meta.Interfaces;
using System;
using System.Linq;
using System.Text;

namespace Core.Generators.CSharp
{

    public class CSharpGenerator : Generator
    {
        const int indentStep = 2;
        private static readonly string GeneratedAttribute = $"[System.CodeDom.Compiler.GeneratedCode(\"{ReservedWords.CompilerName}\", \"{ReservedWords.CompilerVersion}\")]";
        private static readonly string RecordAttribute = $"[BebopRecord]";
        private const string HotPath = "[System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]";

        private static readonly string WarningBlock = $@"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:{ReservedWords.CompilerVersion}
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------";


        public CSharpGenerator(ISchema schema) : base(schema) { }

        private string FormatDocumentation(string documentation, int spaces)
        {
            var builder = new IndentedStringBuilder(spaces);
            builder.AppendLine("/// <summary>");
            foreach (var line in documentation.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.None))
            {
                builder.AppendLine($"/// {line}");
            }
            builder.AppendLine("/// </summary>");
            return builder.ToString();
        }

        public override string Compile()
        {
            var builder = new IndentedStringBuilder();
            builder.AppendLine(WarningBlock);
            builder.AppendLine("using global::System.Collections.Immutable;");
            builder.AppendLine("using global::System.Linq;");
            builder.AppendLine("using global::Bebop.Attributes;");
            builder.AppendLine("using global::Bebop.Runtime;");
            builder.AppendLine("//");
            builder.AppendLine($"// This source code was auto-generated by {ReservedWords.CompilerName}, Version={ReservedWords.CompilerVersion}.");
            builder.AppendLine("//");

            if (!string.IsNullOrWhiteSpace(Schema.Namespace))
            {
                builder.AppendLine($"namespace {Schema.Namespace.ToPascalCase()} {{");
                builder.Indent(indentStep);
            }
            foreach (var definition in Schema.Definitions.Values)
            {
                var definitionName = definition.Name.ToPascalCase();
                if (!string.IsNullOrWhiteSpace(definition.Documentation))
                {
                    builder.AppendLine(FormatDocumentation(definition.Documentation, 2));
                }
                builder.AppendLine(GeneratedAttribute);
                builder.AppendLine(RecordAttribute);
                if (definition.IsEnum())
                {
                    builder.AppendLine($"public enum {definition.Name} : uint {{");
                    builder.Indent(indentStep);
                    for (var i = 0; i < definition.Fields.Count; i++)
                    {
                        var field = definition.Fields.ElementAt(i);
                        if (!string.IsNullOrWhiteSpace(field.Documentation))
                        {
                            builder.AppendLine(FormatDocumentation(field.Documentation, 6));
                        }
                        if (field.DeprecatedAttribute is not null &&
                            !string.IsNullOrWhiteSpace(field.DeprecatedAttribute.Value))
                        {
                            builder.AppendLine($"[System.Obsolete(\"{field.DeprecatedAttribute.Value}\")]");
                        }
                        builder.AppendLine($"{field.Name} = {field.ConstantValue}{(i + 1 < definition.Fields.Count ? "," : "")}");
                    }
                    builder.Dedent(indentStep);
                    builder.AppendLine("}");
                    builder.AppendLine();
                }
                else if (definition.IsMessage() || definition.IsStruct())
                {
                    var baseName = "Base" + definitionName;
                    builder.AppendLine($"public abstract class {baseName} : System.IEquatable<{baseName}> {{");
                    builder.Indent(indentStep);
                    if (definition.OpcodeAttribute is not null)
                    {
                        builder.AppendLine($"public const uint OpCode = {definition.OpcodeAttribute.Value};");
                    }
                    if (definition.IsMessage())
                    {
                        builder.AppendLine("#nullable enable");
                    }
                    for (var i = 0; i < definition.Fields.Count; i++)
                    {
                        var field = definition.Fields.ElementAt(i);

                        if (!string.IsNullOrWhiteSpace(field.Documentation))
                        {
                            builder.AppendLine(FormatDocumentation(field.Documentation, 4));
                        }
                        if (field.DeprecatedAttribute is not null &&
                            !string.IsNullOrWhiteSpace(field.DeprecatedAttribute.Value))
                        {
                            builder.AppendLine($"[System.Obsolete(\"{field.DeprecatedAttribute.Value}\")]");
                        }
                        if (definition.IsStruct())
                        {
                            builder.AppendLine("[System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]");
                        }
                        else if (definition.IsMessage())
                        {
                            builder.AppendLine(
                                "[System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]");
                        }
                        var type = TypeName(field.Type, string.Empty);
                        var opt = definition.Kind == AggregateKind.Message && IsNullableType(field.Type) ? "?" : "";
                        var setOrInit = definition.IsReadOnly ? "init" : "set";
                        builder.AppendLine($"public {type}{opt} {field.Name.ToPascalCase()} {{ get; {setOrInit}; }}");
                    }
                    if (definition.IsMessage())
                    {
                        builder.AppendLine("#nullable disable");
                    }
                    builder.AppendLine();
                    builder.AppendLine(GenerateEqualityMembers(definition));
                    builder.AppendLine();

                    builder.Dedent(indentStep);
                    builder.AppendLine("}");
                    builder.AppendLine("");
                    builder.AppendLine("/// <inheritdoc />");
                    builder.AppendLine(GeneratedAttribute);
                    builder.AppendLine(RecordAttribute);

                    if (definition.AuthorizeWhenHasAnyOfAttribute is not null)
                    {
                        builder.AppendLine($"[AuthorizeWhenHasAnyOf({definition.AuthorizeWhenHasAnyOfAttribute.Value})]");
                    }

                    var baseInterface = (definition.QueryAttribute, definition.CommandAttribute) switch
                    {
                        var (q, _) when q is not null => $", IRemoteQuery<{q.Value}>",
                        var (_, c) when c is not null => ", IRemoteCommand",
                        _ => string.Empty,
                    };

                    builder.AppendLine($"public sealed class {definitionName} : {baseName}{baseInterface} {{");
                    builder.Indent(indentStep);
                    builder.AppendLine(CompileEncodeHelper(definition, "byte[]", "Encode"));
                    builder.AppendLine();
                    builder.AppendLine(CompileEncodeHelper(definition, "ImmutableArray<byte>", "EncodeAsImmutable"));
                    builder.AppendLine();
                    builder.AppendLine(HotPath);
                    builder.AppendLine($"internal static void EncodeInto({baseName} record, ref BebopWriter writer) {{");
                    builder.Indent(indentStep);
                    builder.AppendLine(CompileEncode(definition));
                    builder.Dedent(indentStep);
                    builder.AppendLine("}");
                    builder.AppendLine();
                    builder.AppendLine(CompileDecodeHelper(definition, "byte[]"));
                    builder.AppendLine();
                    builder.AppendLine(CompileDecodeHelper(definition, "System.ReadOnlySpan<byte>"));
                    builder.AppendLine();
                    builder.AppendLine(CompileDecodeHelper(definition, "System.ReadOnlyMemory<byte>"));
                    builder.AppendLine();
                    builder.AppendLine(CompileDecodeHelper(definition, "System.ArraySegment<byte>"));
                    builder.AppendLine();
                    builder.AppendLine(CompileDecodeHelper(definition, "ImmutableArray<byte>"));
                    builder.AppendLine();
                    builder.AppendLine();
                    builder.AppendLine(HotPath);
                    builder.AppendLine($"internal static {definitionName} DecodeFrom(ref BebopReader reader) {{");
                    builder.Indent(indentStep);
                    builder.AppendLine();
                    // when you do new T() the compile uses System.Activator::CreateInstance
                    // this non-generic variant avoids that penalty hit.
                    // https://devblogs.microsoft.com/premier-developer/dissecting-the-new-constraint-in-c-a-perfect-example-of-a-leaky-abstraction/
                    builder.AppendLine(CompileDecode(definition, false));
                    builder.Dedent(indentStep);
                    builder.AppendLine("}");
                    builder.AppendLine();
                    builder.AppendLine(HotPath);
                    builder.AppendLine($"internal static T DecodeFrom<T>(ref BebopReader reader) where T: {baseName}, new() {{");
                    builder.Indent(indentStep);
                    // a generic decode method that allows for run-time polymorphism 
                    // this will initiate objects via a slower .ctor reflection
                    // the last 16 objects are cached.
                    builder.AppendLine(CompileDecode(definition, true));
                    builder.Dedent(indentStep);
                    builder.AppendLine("}");

                    builder.Dedent(indentStep);
                    builder.AppendLine("}");
                }
            }

            if (!string.IsNullOrWhiteSpace(Schema.Namespace))
            {
                builder.Dedent(indentStep);
                builder.AppendLine("}");
            }
            return builder.ToString();
        }
        /// <summary>
        /// Generates code to implement <see cref="IEquatable{T}"/> in the base defined type.
        /// </summary>
        /// <param name="definition"></param>
        /// <returns></returns>
        private string GenerateEqualityMembers(IDefinition definition)
        {
            var baseName = $"Base{definition.Name.ToPascalCase()}";
            var builder = new IndentedStringBuilder();
            builder.AppendLine($"public bool Equals({baseName} other) {{");
            builder.Indent(indentStep);
            builder.AppendLine("if (ReferenceEquals(null, other)) {");
            builder.Indent(indentStep);
            builder.AppendLine("return false;");
            builder.Dedent(indentStep);
            builder.AppendLine("}");
            builder.AppendLine("if (ReferenceEquals(this, other)) {");
            builder.Indent(indentStep);
            builder.AppendLine("return true;");
            builder.Dedent(indentStep);
            builder.AppendLine("}");

            if (definition is not { Fields: { Count: 0 } })
            {
                var returnStatement = new StringBuilder("return");
                for (var i = 0; i < definition.Fields.Count; i++)
                {
                    var field = definition.Fields.ElementAt(i);
                    var fieldName = field.Name.ToPascalCase();
                    var and = $"{(i == definition.Fields.Count - 1 ? "" : " &&")}";
                    var isNullableType = IsNullableType(field.Type);
                    var nullCheck = isNullableType ? "is null" : "== null";
                    var notNullCheck = isNullableType ? "is not null" : "!= null";
                    // for collections we try to be extra safe to avoid throwing exceptions.
                    returnStatement.Append(field.IsCollection()
                        ? $" ({fieldName} {nullCheck} ? other.{fieldName} {nullCheck} : other.{fieldName} {notNullCheck} && {fieldName}.SequenceEqual(other.{fieldName})){and}"
                        : $" {fieldName} == other.{fieldName}{and}");
                }
                returnStatement.Append(";");
                builder.AppendLine(returnStatement.ToString());
            }
            else
            {
                // if the definition has no properties then we can just return true.
                builder.AppendLine("return true;");
            }

            builder.Dedent(indentStep);
            builder.AppendLine("}");

            builder.AppendLine();

            builder.AppendLine("public override bool Equals(object obj) {");
            builder.Indent(indentStep);
            builder.AppendLine("if (ReferenceEquals(null, obj)) {");
            builder.Indent(indentStep);
            builder.AppendLine("return false;");
            builder.Dedent(indentStep);
            builder.AppendLine("}");
            builder.AppendLine("if (ReferenceEquals(this, obj)) {");
            builder.Indent(indentStep);
            builder.AppendLine("return true;");
            builder.Dedent(indentStep);
            builder.AppendLine("}");
            builder.AppendLine($"if (obj is not {baseName} baseType) {{");
            builder.Indent(indentStep);
            builder.AppendLine("return false;");
            builder.Dedent(indentStep);
            builder.AppendLine("}");

            builder.AppendLine("return Equals(baseType);");
            builder.Dedent(indentStep);
            builder.AppendLine("}");
            builder.AppendLine();
            builder.AppendLine("public override int GetHashCode() {");
            builder.Indent(indentStep);
            builder.AppendLine("int hash = 1;");
            for (var i = 0; i < definition.Fields.Count; i++)
            {
                var field = definition.Fields.ElementAt(i);
                var fieldName = field.Name.ToPascalCase();
                if (definition.IsMessage())
                {
                    var isNullableType = IsNullableType(field.Type);
                    var nullCheck = isNullableType ? "is not null" : "!= null";
                    var value = isNullableType && NeedsValueAppend(field.Type) && definition.IsMessage()
                        ? $"{fieldName}.Value.GetHashCode();"
                        : $"{fieldName}.GetHashCode();";
                    builder.AppendLine($"if ({fieldName} {nullCheck}) hash ^= {value}");
                }
                else
                {
                    builder.AppendLine($"hash ^= {fieldName}.GetHashCode();");
                }
            }
            builder.AppendLine("return hash;");
            builder.Dedent(indentStep);
            builder.AppendLine("}");
            builder.AppendLine();
            builder.AppendLine(
                $"public static bool operator ==({baseName} left, {baseName} right) => Equals(left, right);");
            builder.AppendLine(
                $"public static bool operator !=({baseName} left, {baseName}  right) => !Equals(left, right);");
            return builder.ToString();
        }

        public override void WriteAuxiliaryFiles(string outputPath)
        {

        }

        /// <summary>
        ///     Generate a C# type name for the given <see cref="TypeBase"/>.
        /// </summary>
        /// <param name="type">The field type to generate code for.</param>
        /// <param name="arraySizeVar">A variable name that will be formatted into the array initializer</param>
        /// <returns>The C# type name.</returns>
        private string TypeName(in TypeBase type, string arraySizeVar = "")
        {
            return type switch
            {
                ScalarType st => st.BaseType switch
                {
                    BaseType.Bool => "bool",
                    BaseType.Byte => "byte",
                    BaseType.UInt32 => "uint",
                    BaseType.Int32 => "int",
                    BaseType.Float32 => "float",
                    BaseType.Float64 => "double",
                    BaseType.String => "string",
                    BaseType.Guid => "System.Guid",
                    BaseType.UInt16 => "ushort",
                    BaseType.Int16 => "short",
                    BaseType.UInt64 => "ulong",
                    BaseType.Int64 => "long",
                    BaseType.Date => "System.DateTime",
                    _ => throw new ArgumentOutOfRangeException(st.BaseType.ToString())
                },
                ArrayType { MemberType: ScalarType { BaseType: BaseType.Byte } } at =>
                    $"ImmutableArray<{TypeName(at.MemberType)}>",
                ArrayType at =>
                    $"{(at.MemberType is ArrayType ? ($"{TypeName(at.MemberType, arraySizeVar)}[]") : $"{TypeName(at.MemberType)}[{arraySizeVar}]")}",
                MapType mt =>
                    $"System.Collections.Generic.Dictionary<{TypeName(mt.KeyType)}, {TypeName(mt.ValueType)}>",
                DefinedType dt => $"{(IsEnum(dt) ? string.Empty : "Base")}{dt.Name}",
                _ => throw new InvalidOperationException($"GetTypeName: {type}")
            };
        }

        /// <summary>
        ///     Generate the body of the <c>DecodeFrom</c> function for the given <see cref="IDefinition"/>.
        /// </summary>
        /// <param name="definition">The definition to generate code for.</param>
        /// <param name="useGenerics"></param>
        /// <returns>The generated C# <c>DecodeFrom</c> function body.</returns>
        public string CompileDecode(IDefinition definition, bool useGenerics)
        {
            return definition.Kind switch
            {
                AggregateKind.Message => CompileDecodeMessage(definition, useGenerics),
                AggregateKind.Struct => CompileDecodeStruct(definition, useGenerics),
                _ => throw new InvalidOperationException(
                    $"invalid CompileDecode kind: {definition.Kind} in {definition}")
            };
        }

        private string CompileDecodeStruct(IDefinition definition, bool useGenerics)
        {
            var builder = new IndentedStringBuilder();
            int i = 0;
            foreach (var field in definition.Fields)
            {
                builder.AppendLine($"{TypeName(field.Type)} field{i};");
                builder.AppendLine($"{CompileDecodeField(field.Type, $"field{i}")}");
                i++;
            }

            builder.AppendLine($"return new {(useGenerics ? "T" : definition.Name.ToPascalCase())} {{");
            builder.Indent(indentStep);
            i = 0;
            foreach (var field in definition.Fields)
            {
                builder.AppendLine($"{field.Name.ToPascalCase()} = field{i++},");
            }
            builder.Dedent(indentStep);
            builder.AppendLine("};");
            return builder.ToString();
        }

        /// <summary>
        ///     Generate the body of the <c>DecodeFrom</c> function for the given <see cref="IDefinition"/>,
        ///     given that its "kind" is Message.
        /// </summary>
        /// <param name="definition">The message definition to generate code for.</param>
        /// <param name="useGenerics"></param>
        /// <returns>The generated C# <c>DecodeFrom</c> function body.</returns>
        private string CompileDecodeMessage(IDefinition definition, bool useGenerics)
        {
            var builder = new IndentedStringBuilder();
            builder.AppendLine($"var record = new {(useGenerics ? "T" : definition.Name.ToPascalCase())}();");
            builder.AppendLine("var length = reader.ReadRecordLength();");
            builder.AppendLine("var end = unchecked((int) (reader.Position + length));");
            builder.AppendLine("while (true) {");
            builder.Indent(indentStep);
            builder.AppendLine("switch (reader.ReadByte()) {");
            builder.Indent(indentStep);

            // 0 case: end of message
            builder.AppendLine("case 0:");
            builder.Indent(indentStep);
            builder.AppendLine("return record;");
            builder.Dedent(indentStep);

            // cases for fields
            foreach (var field in definition.Fields)
            {
                builder.AppendLine($"case {field.ConstantValue}:");
                builder.Indent(indentStep);
                builder.AppendLine($"{CompileDecodeField(field.Type, $"record.{field.Name.ToPascalCase()}")}");
                builder.AppendLine("break;");
                builder.Dedent(indentStep);
            }

            // default case: unknown, skip to end of message
            builder.AppendLine("default:");
            builder.Indent(indentStep);
            builder.AppendLine("reader.Position = end;");
            builder.AppendLine("return record;");
            builder.Dedent(indentStep);

            // end switch:
            builder.Dedent(indentStep);
            builder.AppendLine("}");

            // end while:
            builder.Dedent(indentStep);
            builder.AppendLine("}");
            return builder.ToString();
        }


        private string CompileDecodeField(TypeBase type, string target, int depth = 0)
        {
            var tab = new string(' ', indentStep);
            var nl = "\n" + new string(' ', depth * 2 * indentStep);
            var i = GeneratorUtils.LoopVariable(depth);
            return type switch
            {
                ArrayType at when at.IsBytes() => $"{target} = reader.ReadBytes();",
                ArrayType at =>
                    $"{{" + nl +
                    $"{tab}var length{depth} = unchecked((int)reader.ReadUInt32());" + nl +
                    $"{tab}{target} = new {TypeName(at, $"length{depth}")};" + nl +
                    $"{tab}for (var {i} = 0; {i} < length{depth}; {i}++) {{" + nl +
                    $"{tab}{tab}{TypeName(at.MemberType)} x{depth};" + nl +
                    $"{tab}{tab}{CompileDecodeField(at.MemberType, $"x{depth}", depth + 1)}" + nl +
                    $"{tab}{tab}{target}[{i}] = x{depth};" + nl +
                    $"{tab}}}" + nl +
                    $"}}",
                MapType mt =>
                    "{" + nl +
                    $"{tab}var length{depth} = unchecked((int)reader.ReadUInt32());" + nl +
                    $"{tab}{target} = new {TypeName(mt)}(length{depth});" + nl +
                    $"{tab}for (var {i} = 0; {i} < length{depth}; {i}++) {{" + nl +
                    $"{tab}{tab}{TypeName(mt.KeyType)} k{depth};" + nl +
                    $"{tab}{tab}{TypeName(mt.ValueType)} v{depth};" + nl +
                    $"{tab}{tab}{CompileDecodeField(mt.KeyType, $"k{depth}", depth + 1)}" + nl +
                    $"{tab}{tab}{CompileDecodeField(mt.ValueType, $"v{depth}", depth + 1)}" + nl +
                    $"{tab}{tab}{target}.Add(k{depth}, v{depth});" + nl +
                    $"{tab}}}" + nl +
                    $"}}",
                ScalarType st => st.BaseType switch
                {
                    BaseType.Bool => $"{target} = reader.ReadByte() != 0;",
                    BaseType.Byte => $"{target} = reader.ReadByte();",
                    BaseType.UInt32 => $"{target} = reader.ReadUInt32();",
                    BaseType.Int32 => $"{target} = reader.ReadInt32();",
                    BaseType.Float32 => $"{target} = reader.ReadFloat32();",
                    BaseType.String => $"{target} = reader.ReadString();",
                    BaseType.Guid => $"{target} = reader.ReadGuid();",
                    BaseType.UInt16 => $"{target} = reader.ReadUInt16();",
                    BaseType.Int16 => $"{target} = reader.ReadInt16();",
                    BaseType.UInt64 => $"{target} = reader.ReadUInt64();",
                    BaseType.Int64 => $"{target} = reader.ReadInt64();",
                    BaseType.Float64 => $"{target} = reader.ReadFloat64();",
                    BaseType.Date => $"{target} = reader.ReadDate();",
                    _ => throw new ArgumentOutOfRangeException()
                },
                DefinedType dt when Schema.Definitions[dt.Name].Kind == AggregateKind.Enum =>
                    $"{target} = reader.ReadEnum<{dt.Name}>();",
                DefinedType dt =>
                    $"{target} = {(string.IsNullOrWhiteSpace(Schema.Namespace) ? string.Empty : $"{Schema.Namespace.ToPascalCase()}.")}{dt.Name.ToPascalCase()}.DecodeFrom(ref reader);",
                _ => throw new InvalidOperationException($"CompileDecodeField: {type}")
            };
        }

        /// <summary>
        ///     Generates the body of various helper methods to encode the given <see cref="IDefinition"/>
        /// </summary>
        /// <param name="definition"></param>
        /// <param name="bufferType"></param>
        /// <param name="methodName"></param>
        /// <returns></returns>
        public string CompileEncodeHelper(IDefinition definition, string bufferType, string methodName)
        {
            var returnMethod = bufferType.Equals("ImmutableArray<byte>") ? "ToImmutableArray" : "ToArray";
            var builder = new IndentedStringBuilder();
            builder.AppendLine(HotPath);
            builder.AppendLine($"public static {bufferType} {methodName}(Base{definition.Name.ToPascalCase()} record) {{");
            builder.Indent(indentStep);
            builder.AppendLine("var writer = BebopWriter.Create();");
            builder.AppendLine("EncodeInto(record, ref writer);");
            builder.AppendLine($"return writer.{returnMethod}();");
            builder.Dedent(indentStep);
            builder.AppendLine("}");
            builder.AppendLine("");
            builder.AppendLine(HotPath);
            builder.AppendLine($"public {bufferType} {methodName}() {{");
            builder.Indent(indentStep);
            builder.AppendLine("var writer = BebopWriter.Create();");
            builder.AppendLine("EncodeInto(this, ref writer);");
            builder.AppendLine($"return writer.{returnMethod}();");
            builder.Dedent(indentStep);
            builder.AppendLine("}");
            return builder.ToString();
        }

        /// <summary>
        ///     Generates the body of various helper methods to decode the given <see cref="IDefinition"/>
        /// </summary>
        /// <param name="definition"></param>
        /// <param name="bufferType"></param>
        /// <returns></returns>
        public string CompileDecodeHelper(IDefinition definition, string bufferType)
        {
            var builder = new IndentedStringBuilder();
            builder.AppendLine(HotPath);
            builder.AppendLine($"public static T DecodeAs<T>({bufferType} record) where T : Base{definition.Name.ToPascalCase()}, new() {{");
            builder.Indent(indentStep);
            builder.AppendLine("var reader = BebopReader.From(record);");
            builder.AppendLine("return DecodeFrom<T>(ref reader);");
            builder.Dedent(indentStep);
            builder.AppendLine("}");
            builder.AppendLine();
            builder.AppendLine(HotPath);
            builder.AppendLine($"public static {definition.Name.ToPascalCase()} Decode({bufferType} record) {{");
            builder.Indent(indentStep);
            builder.AppendLine("var reader = BebopReader.From(record);");
            builder.AppendLine($"return DecodeFrom(ref reader);");
            builder.Dedent(indentStep);
            builder.AppendLine("}");
            builder.AppendLine();

            return builder.ToString();
        }

        /// <summary>
        ///     Generate the body of the <c>EncodeTo</c> function for the given <see cref="IDefinition"/>.
        /// </summary>
        /// <param name="definition">The definition to generate code for.</param>
        /// <returns>The generated C# <c>EncodeTo</c> function body.</returns>
        public string CompileEncode(IDefinition definition)
        {
            return definition.Kind switch
            {
                AggregateKind.Message => CompileEncodeMessage(definition),
                AggregateKind.Struct => CompileEncodeStruct(definition),
                _ => throw new InvalidOperationException(
                    $"invalid CompileEncode kind: {definition.Kind} in {definition}")
            };
        }

        private string CompileEncodeMessage(IDefinition definition)
        {
            var builder = new IndentedStringBuilder();
            builder.AppendLine($"var pos = writer.ReserveRecordLength();");
            builder.AppendLine($"var start = writer.Length;");
            foreach (var field in definition.Fields)
            {
                if (field.DeprecatedAttribute is not null)
                {
                    continue;
                }
                builder.AppendLine("");

                var isNullableType = IsNullableType(field.Type);
                var nullCheck = isNullableType ? "is not null" : "!= null";
                builder.AppendLine($"if (record.{field.Name.ToPascalCase()} {nullCheck}) {{");
                builder.Indent(indentStep);
                builder.AppendLine($"writer.WriteByte({field.ConstantValue});");
                builder.AppendLine(isNullableType && NeedsValueAppend(field.Type)
                    ? $"{CompileEncodeField(field.Type, $"record.{field.Name.ToPascalCase()}.Value")}"
                    : $"{CompileEncodeField(field.Type, $"record.{field.Name.ToPascalCase()}")}");
                builder.Dedent(indentStep);
                builder.AppendLine("}");
            }
            builder.AppendLine("writer.WriteByte(0);");
            builder.AppendLine("var end = writer.Length;");
            builder.AppendLine("writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));");
            return builder.ToString();
        }

        private string CompileEncodeStruct(IDefinition definition)
        {
            var builder = new IndentedStringBuilder();
            foreach (var field in definition.Fields)
            {
                builder.AppendLine($"{CompileEncodeField(field.Type, $"record.{field.Name.ToPascalCase()}")}");
            }
            return builder.ToString();
        }

        private static bool IsNullableType(TypeBase type)
        {
            return type switch
            {
                DefinedType => true,
                ArrayType { MemberType: ScalarType { BaseType: BaseType.Byte } } => false,
                ArrayType => true,
                MapType => true,
                ScalarType => true,
                _ => throw new InvalidOperationException($"CompileEncodeField: {type}")
            };
        }

        private bool NeedsValueAppend(TypeBase type)
        {
            return type switch
            {
                ScalarType { BaseType: BaseType.String } => false,
                DefinedType dt when IsEnum(dt) => true,
                DefinedType => false,
                ScalarType => true,
                _ => false
            };
        }

        private bool IsEnum(DefinedType dt)
        {
            return Schema.Definitions[dt.Name].Kind == AggregateKind.Enum;
        }

        private string CompileEncodeField(TypeBase type, string target, int depth = 0, int indentDepth = 0)
        {
            var tab = new string(' ', indentStep);
            var nl = "\n" + new string(' ', indentDepth * indentStep);
            var i = GeneratorUtils.LoopVariable(depth);
            return type switch
            {
                ArrayType at when at.IsBytes() => $"writer.WriteBytes({target});",
                ArrayType at when at.IsFloat32s() => $"writer.WriteFloat32S({target});",
                ArrayType at when at.IsFloat64s() => $"writer.WriteFloat64S({target});",
                ArrayType at =>
                    $"{{" + nl +
                    $"{tab}var length{depth} = unchecked((uint){target}.Length);" + nl +
                    $"{tab}writer.WriteUInt32(length{depth});" + nl +
                    $"{tab}for (var {i} = 0; {i} < length{depth}; {i}++) {{" + nl +
                    $"{tab}{tab}{CompileEncodeField(at.MemberType, $"{target}[{i}]", depth + 1, indentDepth + 2)}" + nl +
                    $"{tab}}}" + nl +
                    $"}}",
                MapType mt =>
                    $"writer.WriteUInt32(unchecked((uint){target}.Count));" + nl +
                    $"foreach (var kv{depth} in {target}) {{" + nl +
                    $"{tab}{CompileEncodeField(mt.KeyType, $"kv{depth}.Key", depth + 1, indentDepth + 1)}" + nl +
                    $"{tab}{CompileEncodeField(mt.ValueType, $"kv{depth}.Value", depth + 1, indentDepth + 1)}" + nl +
                    $"}}",
                ScalarType st => st.BaseType switch
                {
                    BaseType.Bool => $"writer.WriteByte({target});",
                    BaseType.Byte => $"writer.WriteByte({target});",
                    BaseType.UInt32 => $"writer.WriteUInt32({target});",
                    BaseType.Int32 => $"writer.WriteInt32({target});",
                    BaseType.Float32 => $"writer.WriteFloat32({target});",
                    BaseType.Float64 => $"writer.WriteFloat64({target});",
                    BaseType.String => $"writer.WriteString({target});",
                    BaseType.Guid => $"writer.WriteGuid({target});",
                    BaseType.UInt16 => $"writer.WriteUInt16({target});",
                    BaseType.Int16 => $"writer.WriteInt16({target});",
                    BaseType.UInt64 => $"writer.WriteUInt64({target});",
                    BaseType.Int64 => $"writer.WriteInt64({target});",
                    BaseType.Date => $"writer.WriteDate({target});",
                    _ => throw new ArgumentOutOfRangeException()
                },
                DefinedType dt when Schema.Definitions[dt.Name].Kind == AggregateKind.Enum =>
                    $"writer.WriteEnum<{dt.Name}>({target});",
                DefinedType dt =>
                    $"{(string.IsNullOrWhiteSpace(Schema.Namespace) ? string.Empty : $"{Schema.Namespace.ToPascalCase()}.")}{dt.Name.ToPascalCase()}.EncodeInto({target}, ref writer);",
                _ => throw new InvalidOperationException($"CompileEncodeField: {type}")
            };
        }
    }
}
